[toc]

# `JsonUtility`



[文章引用：官方介绍https://docs.unity.cn/cn/2021.3/ScriptReference/JsonUtility.ToJson.html]

## 一：介绍

`JsonUtility`是unity内置的`json`处理工具，轻量，方便，很适合移动端。

## 二：特点

1. **轻量级且高效**

   - 专为 Unity 优化，序列化和反序列化的速度较快，适合移动端或性能敏感的场景
   - 不需要依赖第三方库，减少项目体积

2. **与 Unity 类型兼容性好**

   - 支持序列化 Unity 内置类型（如 `Vector3`、`Color`、`Quaternion` 等）和标记了 `[Serializable]` 的自定义类

3. **安全序列化**

   - 传入的对象必须是`MonoBehaviour`、`ScriptableObject` 或应用了 `Serializable` 属性的普通类/结构

   - 默认只序列化公有字段或标记了 `[SerializeField]` 的私有字段，避免意外暴露数据

## 三：静态函数

`JsonUtility`包括3个静态函数

1. `ToJson(object target, bool prettyPrint)`
   1. `object`： 要转换为 JSON 形式的对象
   2. `prettyPrint`：是否展示可读性。 true：格式化输出以实现可读性。false：格式化输出以实现最小大小。默认为 false。
2. `FromJson(string text)`
   1. 返回一个T对象的实例
3. `FromJsonOverWrite(string text, object objectToOverwrite)`
   1. 与`FormJson`类似，只是它将 JSON 数据加载到现有对象中，而不是创建新对象并将 JSON 数据加载到其中。

## 四：缺点

1. 不支持复杂数据结构

   - **字典（`Dictionary`）**：`JsonUtility` 无法直接序列化字典，但可以通过 `List<KeyValuePair>` 或两个独立的 `List`（键和值）间接实现（需自定义序列化逻辑）。
   - **多态类型**：无法序列化基类引用指向子类对象的场景（如 `Animal animal = new Dog()`）。
   - **泛型集合**：例如 `List<T>` 如果 `T` 是自定义类型，需确保 `T` 标记了 `[Serializable]`。
   - **嵌套类型**：若类中包含未标记 `[Serializable]` 的嵌套类或结构体，会被忽略。
   
2.  **根对象必须为具体类**
   
   - 直接序列化数组或列表会失败：
   
     ```csharp
     List<int> numbers = new List<int> { 1, 2, 3 };
     string json = JsonUtility.ToJson(numbers); // 错误！无法直接序列化 List
     ```
     
   - 必须使用包装类：
   
     ```csharp
     [Serializable]
     public class Wrapper { public List<int> numbers; }
     Wrapper wrapper = new Wrapper { numbers = numbers };
     string json = JsonUtility.ToJson(wrapper); // 正确
     ```
   
3. **灵活性不足**
   
   - **无法自定义序列化逻辑**：例如无法忽略某些字段、自定义字段名称、处理循环引用等。
   - **无法处理特殊类型**：如 `DateTime`、`TimeSpan` 需要手动转换为字符串或数值。
   
4. **忽略 null 值**
   
   - 默认行为：若字段值为 `null`，序列化时会直接忽略该字段。
   - 问题：反序列化时，若 JSON 中缺失字段，目标对象中的字段会被设为 `default(T)`，而不是保留原来的 `null`（可能导致数据歧义）。
   
5. **版本兼容性差**
   
   - 新增字段：旧 JSON 数据反序列化后，新增字段会被设为 `default(T)`，无法自动继承默认值。
   - 删除字段：JSON 中存在但类中已删除的字段会被静默忽略，可能导致数据丢失。

## 五：注意事项

### ①：FormToJson

> 当 JSON 数据缺少某些字段时，这些字段会被赋予其类型的默认值（`default(T)`）
>
> 而不是你在类定义中通过字段初始化或构造函数设置的初始值。

这是因为，在反序列时，unity会通过一种机制，==直接创建对象实例跳过构造函数和字段初始化过程== ，因此所赋的初始化值并不会生效，而是字段的默认值，比==default(int) 是 0==，

<span style="color: Orange;"> **那么，为什么会有这种行为**</span>？

- **性能优化**：跳过构造函数和字段初始化可以加快反序列化速度，尤其对大量数据或频繁操作更友好。
- **数据覆盖原则**：JSON 数据被视为“真相来源”，反序列化的目的是将数据填充到对象中，而不是执行对象的初始化逻辑。

<span style="color: Orange;"> **怎么解决这个问题**</span>？

- <span style="color: Red"> **显式设置默认值**</span>：类中定义一个设置默认值的方法`SetDefaultData()`，并在反序列化后调用

  ```csharp
  [Serializable]
  public class PlayerData
  {
      public int health;
      public string name;
  
      public void SetDefaults()
      {
          health = 100;
          name = "Unknown";
      }
  }
  // 反序列化后调用
  PlayerData data = JsonUtility.FromJson<PlayerData>(json);
  data.SetDefaults();
  ```

- <span style="color: Red"> **使用 `ISerializationCallbackReceiver` 接口**</span> ：Unity 提供此接口用于在序列化前后执行自定义逻辑

  ```csharp
  [Serializable]
  public class PlayerData : ISerializationCallbackReceiver
  {
      public int health = 100;
      public string name = "Unknown";
  
      // 反序列化完成后触发
      public void OnAfterDeserialize()
      {
          // 主动覆盖默认值
          if (health == 0) 
              health = 100;
          if (string.IsNullOrEmpty(name)) 
              name = "Unknown";
      }
      public void OnBeforeSe\rialize() { }
  }
  ```
