[Toc]

# `LitJson`

## 一：介绍

`LitJson` 是一个专为 .NET 设计的轻量级 JSON 处理库，支持序列化和反序列化 JSON 数据。

## 二：特点

1. **快速且轻量**  
   - 无外部依赖，仅包含几个核心类，适合嵌入到项目中。
   - 适用于小型到中型数据处理场景，性能高效。
3. **灵活的反射机制**  
   - 默认支持公共字段/属性的序列化，可通过配置处理私有字段。
   - 支持自定义 JSON 键名映射（通过 `JsonProperty` 特性）。
4. **流式处理与配置**  
   - 提供 `JsonReader` 和 `JsonWriter` 类，支持流式读写 JSON 数据。
   - 可配置 JSON 格式（如允许注释、单引号字符串等）。

## 三：使用

1. `JsonMapper.ToJson(object obj)`

   1. 将对象转化为`Json`字符串

      ```csharp
      public class SettingData
      {
          public float bgmVolume { get; set; }
          public float gameVolume{ get; set; }
      }
      
      SettingData setting = new SettingData 
      { 
          bgmVolume = 1.0f,
          gameVolume = 1.0f
      };
      string json = JsonMapper.ToJson(setting);
      Debug.Log(json); // 输出：{"bgmVolume":1.0,"gameVolume":1.0}
      ```

2. `JsonMapper.ToObject<T>(string json)`

   1. 将字符串反序列化为指定类型的对象

      ```csharp
      string json = "\"bgmVolum":1.0,\"gameVolume\":1.0";
      SettingData data = JsonMapper.ToObject<SettingData>(json);
      Debug.Log(data.bgmVolume); // 输出：1.0f
      ```

3. `JsonMapper.ToObject(string json)`

   1. 将`json`字符串反序列为`JsonData`对象

      ```csharp
      string json = "\"bgmVolum":1.0,\"gameVolume\":1.0";
      JsonData jsonData = JsonMapper.ToObject(json);
      Debug.Log(jsonData["bgmVolume"]); // 输出：1.0f
      ```

4. `JsonReader`和`JsonWriter`

   1. 用于读写 JSON 数据，提供更灵活的 JSON 数据处理方式

   2. `JsonWriter` 可以用于构建嵌套 JSON 结构

      ```csharp
      public class DataWriter
      {
          public static void Main()
          {
              StringBuilder sb = new StringBuilder();
              JsonWriter writer = new JsonWriter(sb);
              writer.WriteArrayStart();
              writer.Write(1);
              writer.Write(2);
              writer.Write(3);
              writer.WriteObjectStart();
              writer.WritePropertyName("color");
              writer.Write("blue");
              writer.WriteObjectEnd();
              writer.WriteArrayEnd();
              Debug.Log(sb.ToString()); // 输出：[1,2,3,{"color":"blue"}]
          }
      }
      ```

   3. `JsonReader` : 配置`JsonReader`的行为，例如是否允许注释和单引号字符串

      ```csharp
      JsonReader reader = new JsonReader(json);
      reader.AllowComments = true;
      reader.AllowSingleQuotedStrings = true;
      JsonData data = JsonMapper.ToObject(reader);
      ```

## 四：注意事项

- 在使用`LitJson`进行序列化时，不需要为类添加`[System.Serializable]`特性，这是因为`litJson`是直接通过反射访问的字段/属性。

- 在默认情况下，仅序列化`Public`字段，如要需要序列号private字段 : 需通过 `JsonMapper.Reflection` 配置

  ```csharp
  JsonMapper.Reflection.GetFieldFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
  ```

- 如果当遇到需要键名与字段名不一致的情况，可以用`JsonProperty`特性显示指定

  ```csharp
  public class SettingData
  {
      [JsonProperty("BGMVolume")]
      public float bgmVolume { get; set; } // 映射到 JSON 的 "BGMVolume"
  }
  ```

- 如果对象之间存在继承关系（ `SettingData`: `Data` ) , 反序列化时需要显示指定类型

  ```csharp
  // 序列化子类
  SettingData setting = new SettingData 
  { 
      bgmVolume = 1.0f,
      gameVolume = 1.0f
  };
  string json = JsonMapper.ToJson(setting);
  
  // 反序列化时需指定具体类型
  SettingData setting = JsonMapper.ToObject<SettingData>(json); // ✓
  Data data = JsonMapper.ToObject<Data>(json);   // ✗: 丢失子类字段
  ```

  