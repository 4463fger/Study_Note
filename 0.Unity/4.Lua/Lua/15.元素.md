[toc]

# Lua 元表（Metatable）详解

元表是 Lua 中用于自定义表行为的核心机制，

通过元表可以实现**运算符重载**、**继承**、**自定义访问逻辑**等功能。以下结合代码示例详细说明元表的用法。

---

## 一、元表基本概念

### 1. 元表的作用
- 任何表都可以作为另一个表的元表。
- 元表定义了表在**特定操作**（如加减、比较、转换等）时的行为。
- 当对表执行某些操作时，Lua 会自动查找元表中的对应方法（元方法）。

---

## 二、设置元表

### 1. 使用 `setmetatable`

```lua
meta = {}
myTable = {}
setmetatable(myTable, meta)
```

> **关键特性**：
- `setmetatable(子表, 元表)`：为表设置元表。
- 后续对 `myTable` 的特殊操作会触发元表中的方法。

---

## 三、元方法详解

### 1. `__tostring`：自定义字符串转换

```lua
meta = {
    __tostring = function(t)
        return t.name
    end
}
myTable = { name = "Lua" }
setmetatable(myTable, meta)
print(myTable)  -- 输出: Lua
```

> **触发条件**：
- 当表被转换为字符串（如 `print`）时调用。

---

### 2. `__call`：将表当作函数调用

```lua
meta2 = {
    __call = function(a, b)
        print(a)      -- a 是调用者（myTable2）
        print(b)      -- b 是参数（1）
        print("Lua学习2")
    end
}
myTable2 = {}
setmetatable(myTable2, meta2)
myTable2(1)  -- 输出: table, 1, Lua学习2
```

> **触发条件**：
- 当表被当作函数调用（如 `myTable2(1)`）时调用。
- `__call` 的第一个参数是表本身。

---

### 3. 运算符重载

```lua
meta4 = {
    __add = function(t1, t2) return "加" end,
    __sub = function(t1, t2) return "减" end,
    __mul = function(t1, t2) return "乘" end,
    __div = function(t1, t2) return "除" end,
    __mod = function(t1, t2) return "取余" end,
    __pow = function(t1, t2) return "幂" end,
    __eq = function(t1, t2) return true end,
    __lt = function(t1, t2) return true end,
    __le = function(t1, t2) return true end,
    __concat = function(t1, t2) return "拼接" end
}
myTable4 = {} 
myTable5 = {}
setmetatable(myTable4, meta4)
setmetatable(myTable5, meta4)
print(myTable4 + myTable5)  -- 输出: 加
print(myTable4 == myTable5) -- 输出: true
```

> **关键特性**：
- 运算符重载通过元方法实现。
- 操作符 `+`, `-`, `*`, `/`, `%`, `^`, `==`, `<`, `<=`, `..` 分别对应 `__add`, `__sub` 等。
- **注意**：比较操作符要求两个表的元表一致。

---

### 4. `__index`：访问不存在的键

```lua
meta6 = {
    __index = { age = 1 }
}
myTable6 = {}
setmetatable(myTable6, meta6)
print(myTable6.age)  -- 输出: 1（从元表中查找）
```

> **触发条件**：
- 当访问表中不存在的键时，Lua 会到元表的 `__index` 指定的表中查找。
- `__index` 可以是一个表或函数：
  - 如果是表：查找该表。
  - 如果是函数：调用函数并传递键作为参数。

```lua
meta6.__index = function(t, k)
    return "未知键"
end
print(myTable6.name)  -- 输出: 未知键
```

---

### 5. `__newindex`：赋值不存在的键

```lua
meta7 = {
    __newindex = function(t, k, v)
        print("赋值:", k, v)
    end
}
myTable7 = {}
setmetatable(myTable7, meta7)
myTable7.age = 1  -- 输出: 赋值: age 1
print(myTable7.age)  -- 输出: nil（未实际赋值）
```

> **关键特性**：
- 当赋值给一个不存在的键时，`__newindex` 会被调用。
- 默认不会修改原始表，而是通过元方法处理。
- 若希望直接赋值，可使用 `rawset(t, k, v)`。

---

## 四、元表常用操作函数

### 1. 获取元表

```lua
print(getmetatable(myTable6))  -- 输出: 表对象
```

### 2. 原始访问（绕过元表）

```lua
rawget(t, key)  -- 直接访问表中的值（不触发 __index）
rawset(t, key, value)  -- 直接设置表中的值（不触发 __newindex）
```

---

## 五、元表的典型应用场景

### 1. 实现继承

```lua
Parent = { name = "父类" }
Child = {}
setmetatable(Child, { __index = Parent })
print(Child.name)  -- 输出: 父类
```

### 2. 自定义集合类型

```lua
Array = {}
function Array:new()
    local t = {}
    setmetatable(t, self)
    self.__index = self
    return t
end
a = Array:new()
print(a.size)  -- 输出: nil（可通过 __index 提供默认值）
```

### 3. 资源管理

```lua
File = {}
function File:open(path)
    local f = io.open(path)
    setmetatable(f, {
        __gc = function(self)
            print("关闭文件")
            self:close()
        end
    })
    return f
end
```

---

## 六、常见注意事项

1. **元表循环引用**：
   - 避免元表之间相互引用，可能导致内存泄漏。
   - 例如：`setmetatable(A, B)` 且 `setmetatable(B, A)`

2. **性能开销**：
   - 频繁使用元方法（如 `__index`）可能导致性能下降。
   - 对于高频访问字段，建议直接存储在表中。

3. **元方法优先级**：
   - 如果元表中没有定义对应方法，Lua 会按默认规则处理。
   - 例如：`__add` 不存在时，`+` 操作会抛出错误。

4. **调试技巧**：
   - 使用 `debug.getmetatable(t)` 查看元表。
   - 使用 `setmetatable({}, { __tostring = function() return "MyTable" end })` 自定义调试输出。

---

## 七、总结

| 元方法            | 触发条件           | 用途             |
| ----------------- | ------------------ | ---------------- |
| `__tostring`      | 表被转换为字符串时 | 自定义打印输出   |
| `__call`          | 表被当作函数调用时 | 实现表的函数行为 |
| `__add`/`__sub`等 | 使用运算符时       | 运算符重载       |
| `__index`         | 访问不存在的键时   | 实现继承或默认值 |
| `__newindex`      | 赋值不存在的键时   | 控制属性赋值逻辑 |
| `__gc`            | 表被垃圾回收时     | 资源清理         |

> **提示**：元表是 Lua 实现面向对象和元编程的核心机制，合理使用可以大幅提升代码灵活性。
>
> 但需注意性能和设计合理性，避免过度使用导致代码复杂化。