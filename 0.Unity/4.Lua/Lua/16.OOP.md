[toc]

# Lua 面向对象编程详解

Lua 通过表（table）和元表（metatable）机制实现面向对象编程，支持**封装**、**继承**和**多态**三大特性。以下结合代码示例详细说明其实现方式。

---

## 一、封装

### 1. 定义类

```lua
print("********封装********")
Object = {}
Object.id = 1

function Object:Test()
    print(self.id)
end

function Object:new()
    local obj = {}
    self.__index = self
    setmetatable(obj, self)
    return obj
end
```

> **关键特性**：
- `Object` 是一个表，模拟类。
- `:Test()` 使用冒号语法，自动将调用者（`self`）作为第一个参数。
- `new()` 方法用于创建实例，通过 `setmetatable(obj, self)` 并设置 `__index` 为自身，实现继承。

---

### 2. 创建实例并调用方法

```lua
local myObj = Object:new()
print(myObj.id)       -- 输出: 1（从元表中查找）
myObj:Test()          -- 输出: 1（调用 Object 的 Test 方法）
myObj.id = 2
myObj:Test()          -- 输出: 2（实例属性覆盖）
print(Object.id)      -- 输出: 1（类属性未变）
```

> **规则**：
- 实例访问属性时，若自身不存在，则通过元表的 `__index` 查找类属性。
- 修改实例属性不会影响类属性。

---

## 二、继承

### 1. 定义继承方法

```lua
print("********继承********")
function Object:subClass(className)
    _G[className] = {}
    local obj = _G[className]
    self.__index = self
    obj.base = self
    setmetatable(obj, self)
end
```

> **关键特性**：
- `subClass(className)` 动态创建子类（`_G[className]`）。
- 设置子类的元表为父类（`Object`），并通过 `__index` 实现继承。
- `obj.base = self` 记录父类引用，用于后续多态调用。

---

### 2. 创建子类并测试继承

```lua
Object:subClass("Person")
print(Person.id)  -- 输出: 1（继承自 Object 的 id 属性）
```

> **触发机制**：
- `Person` 子类通过元表继承 `Object` 的属性和方法。
- `Person.id` 不存在，通过 `__index` 查找 `Object.id`。

---

## 三、多态

### 1. 定义基类和子类

```lua
print("********多态********")
Object:subClass("GameObject")
GameObject.posX = 0
GameObject.posY = 0

function GameObject:Move()
    self.posX = self.posX + 1
    self.posY = self.posY + 1
    print(self.posX)
    print(self.posY)
end

GameObject:subClass("Player")

function Player:Move()
    self.base.Move(self)  -- 调用父类方法
end
```

> **关键特性**：
- `Player` 重写 `Move` 方法，实现多态。
- `self.base.Move(self)` 显式调用父类方法，避免共享父类表数据。

---

### 2. 测试多态行为

```lua
local p1 = Player.new()
p1:Move()  -- 输出: 1, 1（调用 GameObject 的 Move 方法）
local p2 = Player.new()
p2:Move()  -- 输出: 1, 1（每个实例独立维护状态）
```

> **规则**：
- 子类方法覆盖父类方法时，可通过 `self.base` 调用父类方法。
- 每个实例拥有独立的状态（如 `posX`, `posY`），避免数据共享问题。

---

## 四、关键特性总结

| 特性         | 实现方式                    | 说明                                                         |
| ------------ | --------------------------- | ------------------------------------------------------------ |
| **封装**     | 表 + 元表                   | 通过 `setmetatable` 和 `__index` 实现属性和方法的继承        |
| **继承**     | 动态创建子类 + 元表         | 子类通过元表继承父类的属性和方法，`base` 属性记录父类引用    |
| **多态**     | 方法重写 + 显式调用父类方法 | 子类重写方法后，可通过 `self.base.Method(self)` 调用父类方法 |
| **冒号语法** | `:` 自动传递 `self`         | 简化方法调用，自动将调用者作为第一个参数传入                 |

---

## 五、常见注意事项

1. **避免元表循环引用**：
   ```lua
   A = { __index = B }
   B = { __index = A }  -- 导致无限查找
   ```

2. **性能优化**：
   - 频繁使用 `__index` 可能影响性能，建议直接访问已知属性。
   - 对高频访问的属性，优先存储在实例中而非依赖元表查找。

3. **继承链维护**：
   ```lua
   function SubClass:superMethod()
       self.base.superMethod(self)  -- 显式调用父类方法
   end
   ```

4. **调试技巧**：
   - 使用 `getmetatable(obj)` 查看元表。
   - 使用 `rawget(obj, key)` 绕过元表直接访问属性。

---

## 六、总结

Lua 通过表和元表机制灵活实现了面向对象编程的核心特性：
- **封装**：通过表和元表控制属性访问。
- **继承**：通过元表的 `__index` 实现继承链。
- **多态**：通过方法重写和显式调用父类方法实现多态。

> **提示**：Lua 的面向对象模型轻量且灵活，但需注意合理设计继承链和元表使用，避免过度复杂化代码结构。