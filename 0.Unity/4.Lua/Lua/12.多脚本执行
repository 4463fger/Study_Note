[TOC]

# Lua 全局变量、脚本执行与模块管理详解

## 一、全局变量与本地变量

### 1. 全局变量

```lua
print("*********全局变量和本地变量*********")
a = 1
b = "123"

for i = 1, 2 do
    c = "Lua"
end
print(c)  -- 输出: Lua
```

> **关键特性**：
>
> - 未使用 `local` 声明的变量默认是全局变量
> - 全局变量可在任何作用域访问
> - 在循环或函数中赋值仍为全局变量（如 `c`）

---

### 2. 本地变量

```lua
for i = 1, 2 do
    local d = "Lua"
end
print(d)  -- 输出: nil（本地变量作用域仅限循环内）
```

> **关键特性**：
>
> - 使用 `local` 声明本地变量
> - 本地变量作用域受限于声明位置（函数、循环、块级作用域）
> - 本地变量不会污染全局命名空间

---

## 二、多脚本执行与模块管理

### 1. 使用 `require` 加载脚本

```lua
print("*********多脚本执行*********")
require("Test")
print(testA)
```

> **关键特性**：
> - `require("Test")` 会加载并执行 `Test.lua` 脚本
> - 模块只加载一次（避免重复加载）
> - 模块可定义全局变量或返回值供外部使用

---

### 2. 卸载已加载的脚本

```lua
print("*********脚本卸载*********")
print("Test")  -- 不会触发模块加载
package.loaded["Test"] = nil  -- 强制卸载模块
print(package.loaded["Test"])  -- 输出: nil

local testLa = require("Test")  -- 重新加载模块
print(testLa)  -- 输出模块返回值
```

> **关键特性**：
> - `package.loaded["模块名"]` 存储已加载模块的状态
> - 设置为 `nil` 可强制重新加载模块
> - `require` 返回模块的返回值（通常是一个表）

---

## 三、`_G` 表（全局变量表）

```lua
print("*********大G表*********")
-- _G 表存储所有全局变量
print(_G["a"])      -- 输出: 1（等价于 a）
print(_G["testA"])  -- 输出: Test.lua 中定义的全局变量
```

> **关键特性**：
> - `_G` 是 Lua 的全局变量表（`table` 类型）
> - 所有全局变量存储在 `_G` 中（可通过索引访问）
> - 本地变量 **不会** 存入 `_G` 表

---



## 四、关键特性总结

| 特性               | 说明                                            |
| ------------------ | ----------------------------------------------- |
| **全局变量**       | 无需 `local` 声明，作用域全局，可能污染命名空间 |
| **本地变量**       | 使用 `local` 声明，作用域受限，推荐优先使用     |
| **`require` 加载** | 模块只加载一次，自动缓存到 `package.loaded`     |
| **卸载模块**       | 通过 `package.loaded["模块名"] = nil` 强制卸载  |
| **模块返回值**     | `require` 返回模块定义的返回值（通常是表）      |
| **`_G` 表**        | 存储所有全局变量，本地变量不存入                |
