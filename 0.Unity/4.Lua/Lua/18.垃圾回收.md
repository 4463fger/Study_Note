[toc]

# Lua 垃圾回收

## 一、基础概念

### 1. 自动垃圾回收机制
Lua 使用**标记-扫描垃圾回收算法**，自动追踪并释放不可达对象（如未被引用的表、变量等）。  
**示例代码**：
```lua
test = {id = 1, name = "123"}
print(collectgarbage("count"))  -- 获取当前内存占用（单位：KB）
```

---

## 二、核心函数与操作

### 1. 查看内存占用
```lua
collectgarbage("count") 
```
- **作用**：返回 Lua 当前内存占用值（单位：KB）。
- **换算**：`collectgarbage("count") * 1024` 可得到字节数。

---

### 2. 手动触发垃圾回收
```lua
test = nil  -- 使 test 表不可达
collectgarbage("collect")  -- 执行完整垃圾回收
```
- **作用**：立即释放不可达对象的内存。
- **适用场景**：资源卸载、内存优化时主动调用。

---

### 3. GC 模式切换
```lua
collectgarbage("setmode", "g")  -- 手动模式
collectgarbage("setmode", "k")  -- 自动模式
```
- **自动模式（"k"）**：Lua 根据内存使用自动触发 GC。
- **手动模式（"g"）**：需显式调用 `collectgarbage("collect")`。

---

## 三、Unity 热更新中的 GC 优化

### 1. 为何禁用自动 GC？
- **问题**：自动 GC 可能导致帧率波动（如 GC 期间卡顿）。
- **解决方案**：在 Unity 热更新场景中，建议切换为手动 GC 模式，定期主动回收。

---

### 2. 推荐实践
```lua
collectgarbage("setmode", "g")  -- 禁用自动 GC
-- 在合适时机手动触发
collectgarbage("collect")
```

---

## 四、关键特性总结

| 功能               | 说明                                             |
| ------------------ | ------------------------------------------------ |
| **自动 GC**        | 默认启用，自动回收不可达对象                     |
| **手动 GC**        | 通过 `collectgarbage("collect")` 强制回收        |
| **内存监控**       | `collectgarbage("count")` 返回当前内存占用（KB） |
| **GC 模式切换**    | `"k"` 自动模式，`"g"` 手动模式                   |
| **弱引用表**       | 通过 `__mode` 控制键/值的弱引用，避免内存泄漏    |
| **Unity 优化建议** | 热更新场景中禁用自动 GC，定期手动触发            |

---

## 五、常见注意事项

1. **避免频繁手动 GC**：  
   - 频繁调用 `collectgarbage("collect")` 会增加 CPU 开销。
   - 仅在内存占用激增或关键节点（如场景切换）调用。

2. **内存泄漏排查**：  
   - 如果内存持续增长，可能是未释放的大对象或循环引用。
   - 使用弱引用表管理缓存对象。

3. **GC 参数调优**：  
   - `setpause` 控制 GC 触发频率，`setstepmul` 控制 GC 速度。
   - 在 Unity 中，合理设置参数可减少卡顿。
