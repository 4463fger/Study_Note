[toc]

# C# 调用 Lua 全局函数

## 1. 核心概念

通过 `LuaTable.Global` 可访问 Lua 的 **全局函数**，支持：
- 无参无返回
- 有参有返回
- 多返回值
- 变长参数

---

## 2. 关键代码结构

### 2.1 委托定义

> 需要加特性[CSharpCallLua]，并通过xlua生成代码

```csharp
[CSharpCallLua]
public delegate int CustomCall2(int a); // 有参有返回
[CSharpCallLua]
public delegate int CustomCall3(int a, out bool c); // 多返回值（out）
[CSharpCallLua]
public delegate int CustomCall4(int a, ref bool c); // 多返回值（ref）
[CSharpCallLua]
public delegate void CustomCall5(string a, params object[] args); // 变长参数
```

---

## 3. 函数调用方式

### 3.1 无参无返回
```csharp
// 方式一：使用 Action
Action call = LuaManager.Instance.Global.Get<Action>("testFun");
call();

// 方式二：使用 LuaFunction
LuaFunction lf = LuaManager.Instance.Global.Get<LuaFunction>("testFun");
lf.Call();
```

### 3.2 有参有返回
```csharp
// 方式一：使用自定义委托
CustomCall2 call2 = LuaManager.Instance.Global.Get<CustomCall2>("testFun2");
Debug.Log("有参有返回" + call2(1));

// 方式二：使用 Func
Func<int, int> callByFunc2 = LuaManager.Instance.Global.Get<Func<int, int>>("testFun2");
Debug.Log("有参有返回" + callByFunc2(1));

// 方式三：使用 LuaFunction
LuaFunction callByLua2 = LuaManager.Instance.Global.Get<LuaFunction>("testFun2");
Debug.Log("有参有返回" + callByLua2.Call(30)[0]);
```

### 3.3 多返回值
```csharp
// 方式一：out 参数
CustomCall3 call3 = LuaManager.Instance.Global.Get<CustomCall3>("testFun3");
bool b;
Debug.Log("第一个返回值" + call3(100, out b));
Debug.Log("第二个返回值" + b);

// 方式二：ref 参数
CustomCall4 call4 = LuaManager.Instance.Global.Get<CustomCall4>("testFun3");
bool b2 = false;
Debug.Log("第一个返回值" + call4(100, ref b2));
Debug.Log("第二个返回值" + b2);

// 方式三：LuaFunction
LuaFunction callByLua3 = LuaManager.Instance.Global.Get<LuaFunction>("testFun3");
Debug.Log("第一个返回值" + callByLua3.Call(100)[0]);
Debug.Log("第二个返回值" + callByLua3.Call(100)[1]);
```

### 3.4 变长参数
```csharp
// 方式一：使用自定义委托
CustomCall5 call5 = LuaManager.Instance.Global.Get<CustomCall5>("testFun4");
call5("1", 2, 3);

// 方式二：使用 LuaFunction
LuaFunction lf4 = LuaManager.Instance.Global.Get<LuaFunction>("testFun4");
lf4.Call("1", 2, 3);
```

---

## 5. 注意事项

| 问题类型         | 描述                              | 解决方案                                  |
| ---------------- | --------------------------------- | ----------------------------------------- |
| **类型不匹配**   | C# 委托与 Lua 函数签名不一致      | 确保参数类型和数量完全匹配                |
| **多返回值丢失** | 使用 `Func<T>` 无法接收多个返回值 | 使用 `LuaFunction.Call()` 返回数组        |
| **变长参数异常** | 参数数量或类型不匹配              | 在 Lua 中使用 `...` 接收剩余参数          |
| **委托未注册**   | 未添加 `[CSharpCallLua]` 特性     | 为所有自定义委托添加特性标记              |
| **性能问题**     | 频繁使用 `LuaFunction.Call()`     | 尽量复用委托对象（如 `Action` 或 `Func`） |
