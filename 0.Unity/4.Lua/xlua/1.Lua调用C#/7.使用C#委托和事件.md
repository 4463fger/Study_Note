[toc]

# Lua 调用 C# 委托与事件

## 一、C# 委托调用

> **核心机制**：委托是函数指针，Lua 可通过赋值和组合操作与 C# 委托交互

---

### 1. 创建 Lua 函数并绑定到 C# 委托
```lua
Code7 = CS.LuaCallCsharp.Code7
local obj = Code7()

-- 定义 Lua 函数
local fun = function()
    print("Lua函数Func")
end

-- 委托操作（+=/-= 不可用）
obj.del = fun              -- 第一次赋值必须用 `=`
obj.del = obj.del + fun    -- 添加相同函数
obj.del = obj.del - fun    -- 移除指定函数
obj:del()                  -- 调用委托
obj.del = nil              -- 清空委托
```

> **关键规则**：
>
> - **首次赋值必须用 `=`**，不能直接 `+=`。
> - `+` 表示添加函数，`-` 表示移除函数。
> - `nil` 可清空委托。
---

### 2. 多函数委托调用
```lua
-- 添加多个 Lua 函数
obj.del = fun1 + fun2 + fun3
obj:del() -- 按添加顺序依次调用所有函数
```

> **注意**：
>
> - 委托支持多函数链式调用。
> - 移除函数需精确匹配 Lua 函数引用。
---

## 二、C# 事件调用

> **核心区别**：事件是封装的委托，Lua 不能直接通过 `+=`/`-=` 操作符访问，需通过 C# 提供的方法。

---

### 1. 事件添加与移除
```lua
local fun2 = function()
    print("事件")
end

-- 通过 C# 提供的方法操作事件
obj:eventAction("+", fun2) -- 添加
obj:eventAction("+", fun2) -- 再次添加（重复注册）
obj:eventAction("-", fun2) -- 移除
// C#中编写
obj:DoEvent()              -- 触发事件
obj:ClearEvent()           -- 清空所有事件
```

> **关键点**：
>
> - **事件需通过 `:事件名` 方法操作**
> - 可重复添加相同函数，但需精确匹配引用移除。
---

## 三、C# 对应代码结构

### 1. 委托定义
```csharp
public class Code7
{
    // 定义委托类型
    public delegate void MyDelegate();
    // 公共委托字段
    public MyDelegate del;
    // 事件定义
    public event MyDelegate eventAction;
    // 触发事件方法
    public void DoEvent()
        eventAction?.Invoke();
    // 清空事件
    public void ClearEvent()
        eventAction = null;
}
```

> **说明**：
>
> - `MyDelegate` 是可公开访问的委托类型
> - `eventAction` 是封装的事件，需通过方法操作