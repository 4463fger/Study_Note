[toc]

# 第五节课：Lua 调用 C# 重载函数

## 一、重载函数调用规则

> **核心挑战**：Lua 的 `number` 类型无法区分 `int`、`float` 等 C# 数值类型，导致重载函数调用时可能匹配错误。

---

## 二、基础调用

```lua
Code6 = CS.LuaCallCsharp.Code6
local obj = Code6()

-- 无参重载
print(obj:Calc()) --> 100

-- 双参重载
print(obj:Calc(15, 1)) --> 16

-- 单参重载（自动匹配 int）
print(obj:Calc(10)) --> 10

-- 单参重载（自动匹配 float）
print(obj:Calc(10.2)) --> 10.2
```

> **问题**：
>
> - Lua 的 `number` 无法区分 `int` 与 `float`
> - 相同参数值可能匹配不同重载版本（如 `10` 和 `10.2`）
---

## 三、解决精度问题（强制指定重载）

### 1. 反射获取特定方法
```lua
-- 获取 int 参数的重载方法
local m1 = typeof(Code6):GetMethod("Calc", {typeof(CS.System.Int32)})

-- 获取 float 参数的重载方法
local m2 = typeof(Code6):GetMethod("Calc", {typeof(CS.System.Single)})
```

> **关键点**：
>
> - `typeof(Code6)` 获取 C# 类型
> - `GetMethod(name, parameterTypes)` 精准匹配参数类型
---

### 2. 转换为 Lua 函数调用
```lua
-- 转换为 Lua 可调用函数
local f1 = xlua.tofunction(m1) -- int 参数
local f2 = xlua.tofunction(m2) -- float 参数

-- 成员方法需传入对象
print(f1(obj, 10))      --> 10（int 参数）
print(f2(obj, 10.2))    --> 10.2（float 参数）
```

> **优势**：
>
> - 明确指定调用哪个重载版本
> - 避免 Lua 自动类型转换导致的歧义
---

## 六、参考代码结构（C# 对应）

```csharp
public class Code6
{
    public int Calc() => 100;
    public int Calc(int a, int b) => a + b;
    public int Calc(int a) => a;
    public float Calc(float a) => a;
}
```
