[toc]

# Lua 调用 C# 泛型函数

## 一、泛型函数调用规则

> **核心限制**：Lua 无法直接调用 C# 泛型函数（`<T>`），需通过 XLua 工具或反射显式指定泛型类型参数。

---

## 二、调用场景

### ✅ 支持调用的泛型函数
```lua
obj:TestFun1(child, father)
```
- **条件**：
  - 泛型函数 **有参数且有约束**
  - 示例：`TestFun1<TChild, TFather>(TChild child, TFather father)`

---

### ❌ 不支持调用的泛型函数
#### 1. 无约束泛型函数
```lua
-- obj:TestFun2(child) -- 不支持
```
#### 2. 有约束但无参数的泛型函数
```lua
-- obj:TestFun3() -- 不支持
```
#### 3. 非 `class` 约束的泛型函数
```lua
-- obj:TestFun4(child) -- 不支持
```
---

## 三、强制指定泛型类型参数

### 1. 使用 `xlua.get_generic_method`
```lua
-- 获取泛型方法
local testFun2 = xlua.get_generic_method(CS.LuaCallCsharp.Code12, "TestFun2")
-- 指定泛型类型参数（如 System.Int32）
local testFun2_R = testFun2(CS.System.Int32)
-- 调用成员方法（第一个参数为对象）
testFun2_R(obj, 1)
```

> **关键点**：
>
> - `xlua.get_generic_method` 获取泛型方法。
> - `testFun2(CS.Type)` 指定泛型参数类型。
> - 成员方法需传入对象作为第一个参数。
---

## 四、不同打包方式的限制

### 1. Mono 打包
- **支持泛型参数为值类型或引用类型**。
- **无需额外操作**，直接调用即可。

### 2. IL2CPP 打包
- **限制**：
  - 泛型参数为 **引用类型** 时，可正常调用。
  - 泛型参数为 **值类型** 时，需在 C# 中 **预先调用同类型的泛型函数**，否则 Lua 无法调用。

> **解决方案**：
>
> - 在 C# 中预先调用一次同类型的泛型函数：
>
>   ```csharp
>   public class Code12
>   {
>       public void TestFun2<T>(T value)
>       {
>           // ...
>       }
>       public void Preload()
>       {
>           TestFun2<int>(0); // 预加载 int 类型的泛型函数
>       }
>   }
>   ```
---

## 五、C# 泛型函数定义示例

```csharp
public class Code12
{
    // 支持调用：有参数+有约束
    public void TestFun1<TChild, TFather>(TChild child, TFather father) where TChild : TestChild where TFather : TestFather { }

    // 不支持调用：无约束泛型函数
    public void TestFun2<T>(T value) { }

    // 不支持调用：有约束但无参数
    public void TestFun3<T>() where T : new() { }

    // 不支持调用：非 class 约束
    public void TestFun4<T>(T value) where T : struct { }
}
```
