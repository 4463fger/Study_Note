[toc]

# Lua 调用 C# `ref`/`out` 参数

## 一、`ref` 参数调用

> **核心机制**：`ref` 参数的修改结果会通过 **多返回值** 返回给 Lua，**需传入初始值作为占位符**

```lua
Code5 = CS.LuaCallCsharp.Code_RefAndOut
local obj = Code5()

-- 调用 RefFun 方法
-- 参数顺序：a, ref b, ref c, d
local a, b, c = obj:RefFun(1, 0, 0, 1)
print(a) -- 输出: 100（函数返回值）
print(b) -- 输出: 2（a + d）
print(c) -- 输出: 0（a - d）
```

> **规则**：
>
> - `ref`参数需要传入一个默认值 作为占位符
> - 返回值中，**第一个是函数返回值**，后续依次是 `ref` 参数的修改结果
---

## 二、`out` 参数调用

> **核心机制**：`out` 参数的修改结果会通过 **多返回值** 返回给 Lua，**无需传入初始值**

```lua
-- 调用 OutFun 方法
-- 参数顺序：a, out b, out c, d
local x, y, z = obj:OutFun(1, 100)
print(x) -- 输出: 100（函数返回值）
print(y) -- 输出: 1（a）
print(z) -- 输出: 100（d）
```

> **规则**：
>
> - `out` 参数 **无需传入初始值**。
> - 返回值中，**第一个是函数返回值**，后续依次是 `out` 参数的修改结果。
---

## 三、混合 `ref`/`out` 参数调用

### 1. 示例调用
```lua
-- 调用 RefOutFun 方法
-- 参数顺序：a, out b, ref c
local g, i, t = obj:RefOutFun(20, 1)
print(g) -- 输出: 300（函数返回值）
print(i) -- 输出: 200（out int b = a * 10）
print(t) -- 输出: 40（ref int c = a * 20）
```

> **混合规则**：
>
> - `out` 参数无需传入初始值
> - `ref` 参数需传入初始值（如 `1`）
---

## 四、C# 方法定义（对应 Lua 调用）

```csharp
public class Code_RefAndOut
{
    public int RefFun(int a, ref int b, ref int c, int d)
    {
        b = a + d;
        c = a - d;
        return 100;
    }

    public int OutFun(int a, out int b, out int c, int d)
    {
        b = a;
        c = d;
        return 100;
    }

    public int RefOutFun(int a, out int b, ref int c)
    {
        b = a * 10;
        c = a * 20;
        return 300;
    }
}
```
