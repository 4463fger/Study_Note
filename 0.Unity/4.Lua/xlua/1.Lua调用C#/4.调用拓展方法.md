[toc]

# Lua 调用 C# 扩展方法

## 一、扩展方法调用规则

> **核心前提**：
>
> 扩展方法的静态类必须添加 `[LuaCallCSharp]` 特性，否则 Lua 无法识别该方法。

---

## 二、静态方法调用

```lua
-- 调用 C# 静态方法
Extension = CS.LuaCallCsharp.ExtensionMethod
Extension.Eat() -- 输出: 吃吃
```

> **规则**：
>
> - 通过类名直接调用静态方法（`.`）。
> - 方法需为 `public static`。
---

## 三、拓展方法调用

```lua
-- 创建 C# 实例并调用
local obj = Extension()
obj:Speak("6") -- 输出: 6
```

> **关键点**：
>
> - **成员方法必须用 `:` 调用**（绑定 `self` 参数）。
> - 使用拓展方法，与使用普通成员方法一致，用冒号调用方法
> - 方法需为 `public`。
---

## 四、注意事项与常见问题

### 1. 为何必须加 [LuaCallCSharp] 特性？
- XLua 通过反射注册 C# 类的方法，**未标记的类不会被暴露给 Lua**。
- 特性作用：明确告知 XLua 需要注册该类的扩展方法

---

### 2. 扩展方法的调用限制
- **只能通过实例调用**（如 `obj:Move()`）。
- **不能通过类名直接调用**（如 `Tools.Move(obj)`）。

---

### 3. XLua 代码生成要求
- 修改 C# 代码后，**必须重新生成 XLua 的绑定代码**。
- 通常通过 `xlua gen` 命令或 Unity Editor 插件触发

---

## 五、参考代码结构（C# 对应）

```csharp
// 必须添加 [LuaCallCSharp] 特性
[XLua.LuaCallCSharp]
public static class Tools
{
    public static void Move(this ExtensionMethod obj)
    {
        Debug.Log(obj.name + "移动");
    }
}

public class ExtensionMethod
{
    public string name = "4463";
    public void Speak(string str) { }
    public static void Eat() { }
}
```
