[toc]

# Lua 调用 C# 类

## 一、调用

> **命名空间映射**：`CS.命名空间.类名` 是 Lua 调用 C# 的固定语法。

### 1. 实例化 Unity 原生类
```lua
-- 无参构造
local obj1 = CS.UnityEngine.GameObject()

-- 带参数构造
local obj2 = CS.UnityEngine.GameObject("Lua")
```

> **规则**：
>
> - Lua 中无 `new` 关键字，直接调用类名加括号即实例化。
> - 构造函数参数与 C# 中一致。
---

### 2. 使用静态方法
```lua
GameObject = CS.UnityEngine.GameObject
local obj4 = GameObject.Find("Lua")
print(obj4.transform.position)
```

> **关键点**：
>
> - 静态方法直接通过类名调用（`.`）。
> - `GameObject.Find()` 是 Unity 中查找对象的标准方法。
---

### 3. 调用成员方法
```lua
Vector3 = CS.UnityEngine.Vector3
obj4.transform:Translate(Vector3.right)
```

> **注意**：
>
> - **成员方法必须用 `:` 调用**（绑定 `self` 参数）。
> - `Vector3.right` 是 Unity 静态属性，表示 `(1,0,0)` 方向。
---

## 二、自定义类调用

### 调用 C# 自定义类
```lua
local t = CS.LuaCallCsharp.Test()
t:Speak("狗叫？") -- 输出: 狗叫？
```

> **要求**：
>
> - C# 类需在 `LuaCallCsharp` 命名空间中。
> - 方法 `Speak` 需为 `public`，且 Lua 中使用 `:` 调用。
---

## 三、继承 Mono 的类处理

### 添加脚本组件
```lua
local obj5 = GameObject("加脚本")
// 使用typeof重载，因为Lua不支持泛型
obj5:AddComponent(typeof(CS.LuaCallCsharp.LuaCallCsharp))
```

> **关键限制**：
>
> - **继承 `MonoBehaviour` 的类不能直接 `new`**。
> - 必须通过 `AddComponent(typeof(类名))` 添加组件。
> - `typeof` 是 XLua 提供的方法，用于获取 C# 类型（`System.Type`）。
---

## 四、定义全局变量缓存 C# 类

```lua
GameObject = CS.UnityEngine.GameObject
Vector3 = CS.UnityEngine.Vector3
Debug = CS.UnityEngine.Debug
```

> **优势**：
>
> - 避免重复访问 `CS.UnityEngine`，提升性能。
> - 推荐对高频使用的类进行缓存。
---

## 五、参考代码结构（C# 对应）

```csharp
namespace LuaCallCsharp
{
    public class Test
    {
        public void Speak(string arg) { }
    }

    public class LuaCallCsharp : MonoBehaviour { } // 继承 Mono 的类
}
```
