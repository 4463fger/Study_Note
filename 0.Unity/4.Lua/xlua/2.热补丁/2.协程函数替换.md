[toc]

# 协程热补丁

> 场景：在热更阶段，需要把 C# 中原有的协程逻辑**完全替换成 Lua 实现**，同时保持与 Unity 协程系统的无缝衔接。

---

## 一、C# 原始代码

```csharp
[Hotfix]
public class HotfixMain : MonoBehaviour
{
    // 将被 Lua 替换的协程
    IEnumerator TestCoroutine()
    {
        while (true)
        {
            yield return new WaitForSeconds(1);
            Debug.Log("协程");
        }
    }

    private void Start()
    {
        StartCoroutine(TestCoroutine());
    }
}
```

---

## 二、Lua 热补丁代码

```lua
print("**********协程函数替换**********")

-- 必须引入 xlua 提供的协程工具库
util = require("xlua.util")

xlua.hotfix(CS.Study.HotfixMain, {
    TestCoroutine = function(self)
        -- 返回一个经过 xlua 封装的 Lua 协程函数
        return util.cs_generator(function()
            while true do
                coroutine.yield(CS.UnityEngine.WaitForSeconds(1))
                print("Lua打补丁后的协程")
            end
        end)
    end
})
```

---

## 三、关键 API 说明

| API                       | 作用                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `util.cs_generator(func)` | 把 Lua 协程函数转换成 C# 可识别的 `IEnumerator`，供 Unity 协程系统使用。 |
| `coroutine.yield(obj)`    | 在 Lua 侧“挂起”协程，等价于 C# 的 `yield return obj;` 要求 obj 是 Unity 的 `YieldInstruction` 或其子类。 |

---

## 四、常见坑速查

| 现象                          | 原因/解决                                                    |
| ----------------------------- | ------------------------------------------------------------ |
| 补丁不生效                    | 忘记重新 Generate + Inject；或没有返回 `cs_generator` 包装的对象。 |
| 报错“can not yield C# object” | 把 C# 对象（如 `WaitForSeconds`）直接 `yield` 即可，**不要**在 Lua 侧再包一层 table。 |
| 想 yield 多个指令             | 连续写多个 `coroutine.yield(xxx)`，逻辑与 C# 侧一致。        |
