[toc]

## 一、多函数替换（普通成员方法 & 静态方法）

### C# 原始类
```csharp
[Hotfix]
public class HotfixMain : MonoBehaviour
{
    void Update() { }
    public int Add(int a, int b) => 0;
    public static void Speak(string str) => Debug.Log("哈哈");
}
```

### Lua 热补丁
```lua
print("**********多函数替换**********")

xlua.hotfix(CS.Study.HotfixMain, {
    -- 成员方法：带 self
    Update = function(self)
        print(os.time())
    end,
    Add = function(self, a, b)
        return a + b          -- 修复为正确相加
    end,
    -- 静态方法：无 self
    Speak = function(str)
        print(str)
    end
})
```

### 要点
| 类型     | 参数列表   | 说明                      |
| -------- | ---------- | ------------------------- |
| 成员方法 | 首参为self | 通过self访问实例字段/属性 |
| 静态方法 | 无self     | 与C#静态方法一致          |

---

## 二、构造函数 & 析构函数热补丁

### C# 原始类
```csharp
[Hotfix]
public class HotfixTest
{
    public HotfixTest() => Debug.Log("构造函数");
    ~HotfixTest() { } // 析构函数
}
```

### Lua 热补丁
```lua
xlua.hotfix(CS.Study.HotfixTest, {
    -- 构造函数固定写法：.ctor
    [".ctor"] = function()
        print("热补丁构造函数")
    end,
    -- 析构函数固定写法：Finalize
    Finalize = function()
        print("热补丁析构函数")
    end
})
```

### 要点
- **构造函数**与**析构函数****不会完全替换**原逻辑，而是**先执行原逻辑，再执行Lua补丁逻辑**。
- 固定写法：
  - 构造函数 → `[ ".ctor" ]`
  - 析构函数 → `Finalize`

---

## 三、易错点提醒

| 错误点                          | 正确做法                                      |
| ------------------------------- | --------------------------------------------- |
| 静态方法带self                  | 静态方法Lua函数**不要写self**                 |
| 构造函数写"ctor"或"Constructor" | 固定用`[ ".ctor" ]`                           |
| 泛型类直接写类名                | 需**指定具体泛型参数**，如`CS.Study.A(B)`     |
| 注入失败                        | 检查是否生成代码、是否注入、是否安装Tools工具 |

