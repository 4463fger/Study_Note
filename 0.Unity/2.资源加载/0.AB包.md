[toc]

# AssetBundles-Browser

## Build界面

- Clear Folders : 是否清空文件夹 重新打包
- Copy To StreamingAssets : 是否拷贝到StreamingAssets
- Compression（压缩方式）
  - NoCompression - 不压缩，解压快，包较大，不推荐
  - LZMA - 压缩最小，解压慢 ，用一个资源要解压所有
  - LZ4 - 压缩比LZMA大一点，简易使用，用什么解压什么
- ETI ：在资源包中　不包含资源的类型信息
- FR ： 重新打包时需要重新构建包和ClearFolders不同，不会删除不再存在的包
- ITTC ：增量构建检查时，忽略类型数的更改
- Append Hash ：将文件哈希值附加到资源包名上
- SM ： 严格模式，如果打包时报错，直接失败打包无法成功
- DRB ：运行时构建

# 使用AB包

> 使用中，AB包不能重复加载!!!

```csharp

public class ABStudy : MonoBehaviour
{
    private void Start()
    {
        // AB包不能重复加载!!!
        // 加载AB包
        var ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + "/" + "model");
        // 加载资源
        // var cube =ab.LoadAsset<GameObject>("Cube");
        GameObject cube1 =ab.LoadAsset("Cube",typeof(GameObject)) as GameObject;

        StartCoroutine(LoadAB("sprite" , "youxiang"));
    }

    // 异步加载Ab包
    IEnumerator LoadAB(string abName , string assetName)
    {
        var assetBundle = AssetBundle.LoadFromFileAsync(Application.streamingAssetsPath + "/" + abName);
        yield return assetBundle;

        var a = assetBundle.assetBundle.LoadAssetAsync(assetName,typeof(Sprite));
        yield return a;

        Debug.Log((a.asset as Sprite).name);

        // true:卸载所有AB包和加载的资源
        // false:只卸载AB包
        AssetBundle.UnloadAllAssetBundles(false);
    }
}
```

# AB包依赖

> 一个包中的资源，身上用到了其他AB包中的资源，那么只加载自己，就会导致资源丢失
>
> do : 依赖包一起加载 
>
> 通过主包去获取依赖信息

```csharp
// 1.加载主包
AssetBundle abMain = AssetBundle.LoadFromFile(Application.streamingAssetsPath + "/" + "PC");
// 2.加载主包的固定文件
AssetBundleManifest abMainfest = abMain.LoadAsset<AssetBundleManifest>("AssetBundleManifest");
// 3.得到依赖包的名字
string[] strs = abMainfest.GetAllDependencies("model");
// 4.加载所有依赖包
for (int i = 0; i < strs.Length; i++)
{
    AssetBundle.LoadFromFile(Application.streamingAssetsPath + "/" + strs[i]);
}
```